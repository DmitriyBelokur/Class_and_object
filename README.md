# Классы и объекты
## Базовые понятия ООП
Начнем с того что есть недостаком функционального и процедурного программирования.
К примеру у нас есть концепт очереди. То функциональьный подход разделяет данные и алгоритмы работы с этой очередью. Т.е. алгоритм и данные с которыми работает эта очередь есть две независимые сущности.
Например, добавление элемента в очередь
```
push_queue(queue, value);
``` 
как видим нам необходимо передавать саму очередь как параметр, то есть мы разделяем как и что.
Да можно например определить реализацию функционального подхода как отдельный модуль трансляции, определив например как статическую переменную внутри этого модуля, и вызывать просто интерфейсные функции работы с очередью. Но проблема что этот подход реализован для одного экземпляра. Ну будучи честным есть реализации ООП с помощью функционального подхода.

Программирования с помощью ООП подхода решает эту проблему, т.е. призван решить ее, он рассматривает и алгоритмы и данные как единую сущность.
Далеко отходя от понятий, хочу сказать что сам ООП, т.е. его философия, она не такая как ее реализовывает язык. К примеру когда зарождалась идея ООП, т.е. хотели предоставить идею клеточного организма которые общаються между собой сообщениями. Сам создатель ООП подхода, сказал что он не имеел ввиду ООП как С++.
ООП это подход, стиль программирования, модульность, и т.д. Подхода к описанию очень много. Мной импанирует смысл, это то что ООП призван представить нам наш реальний мир, т.е. выразить все как абстрация, и как объектность. Т.е. к примеру выразить абстракность автомиль форд, а вот его объект это реализация этой абстракции. Объект он представляет из себя данные(характеристики, которые описывают этот объект ) и поведение(т.е. то как управлять этим объектом). Например у нас есть объект у которого есть атрибуты модель, тип двигателя, тип авто, пробег. И есть методы упраления объектом, как внутрение, как внешние. Внешние мы даем наружу чтобы им или управляли, или модифицировали(т.е. меняли состояние), тогда как внутрение это то что происходит внутри объекта. Возращаясь к авто мы имеем внешний интерфейс, нажатия на педаль газа, при этом когда мы вызвали этот интерфейс(послали сообщение объекту), то нутри объекта начинает происходить много измениний, т.е. объект начал менять свое сотоянии, вызываеться внутриние методы работы с двигателем, раскрутка колесс, и т.д.
Хух, что то сказал)

Базовой единицей в ООП есть класс, это и есть инкапсуляция данных и методов(поведения) в единую коробоку. И который предоставляет интерфейс для работы с этой коробкой. И в связи что класс это хорошо инкапсулированаясущность, его удобно переиспользовать или изменять не влияя на внешний интерфейс. Возращаясь к функциональному программированию, скажем так что ООП объединяет данные и алгоритмы работы с этими данными в одну и ту же коробочку.
ООП подход это высокоуровневая абстракция которая призвана решать больше проблему, чем думать на тем как его решать(как представить эти данные к памяти и т.д.), для использующего ваш класс. Хороший пример это контейнер, который у себя инкапсулирует сложную логику выделения памяти, переноса памяти, для вас это прячится за кулисами этого класса, вы просто вызываете методы добавления в вектор, удаления, и вас не парит все сложности.

Но есть и большая избыточность использования этого ООП, люди начинают все в своей программе рассматривать как класс. Еще раз ООП призван решить более сложные технические объекты. Например нет смысла писать какойто парсер ввиде класса, когда его целью есть просто взять с файла данные представленные в одном формате, прдставить его в другом формате. Т.е. смысл этого то что даному парсеру не нужно состоянии. И это есть базовое понятие, т.е. в ООП это возможность сохранять состоянии (например, перемещения игрока по полю, его прокачанные скилы). А вот если не нужно состояние, то для этого прекрасно работает как раз и функциональное програмировние.
Пример же той же очереди. Есть у нас в системе будет только одна очередь, то зачем для этого городить подход с ООП если можно просто написать функциональный подход ввиде модульности, инкапсулируя просто одну только очередь.
Ок я думаю с каким то пониманием вы подошли уже к определения базовых концептов ООП.

Основной единицей есть **класс**. Это просто чертеж, абстракция, прототип, который просто описыват суть какие характеристики(данные) этого класса, и его поведение(при этом есть как внутренне и как ввнешенне).

**Объект** это уже реализация нашего чертижа описанного в классе. Т.е. это уже физическое представления класса. Т.е. этим мы создаем его внутрение атрибутты, т.е. внутренее состояние. Стоит сказать что мы можем созадавать много этих экземпляров, и каждый из них будет иметь свое независимое состояние, но повдение работы с ними одинаковыми.

**Абстракция** есть предоставление только нужной информации окружающей среде, при этом пряча детали имлементации. Т.е. предоставляються только внешние методы для работы с объеектом(типа сообщений). Польза от этого в том что вы можете менять внутренее состояния не меняя его внешний интерфейс.
**Инкапсуляция** это очень близко в абстрации, т.е. это комбинация в одном модуле данные и функции. И данные не доступны для других частей программы, а доступны только через функции. Это еще называют скрытие данных. Т.е. представление единого целого. Например чтобы поменять состояние объекта, не надо менять каждое поле, а происходит измение только через внешнюю функции. Это позволяет соблюдать целостность данных. Если мы до этого использовали структуры, то там поля объекта могли менять в разных частях программы где есть доступ к объекту. Тем самым объект не был в целостном состоянии.
**Наследование** этот термин мы рассотрим дальше в другом разделе
**Полиморфизм** этот термин мы рассотрим дальше в другом разделе 

## Работа с классом
Ок, после того как мы рассмотрели концепции ООП, хотя они реально поверхностные без тонкостей деталей, начнем писать наш первй класс.
Я хочу пошагово реализовать идею работы со стеком. Начиная от определения класса стек и заканчивая реализацией всех конструкторов.
Ок, начнем
Класс имеет что то схожее со структурой, т.е. структура хранит набор связанных данных, но не зависимых друг от друга. Но еще раз для меня структура, это некий логическое объединения данных, я его смысл рассмартриваю как в языке С. Т.е. это Plain Old Data, данные которые меняються не зависимо  друг от друга, в разных частях программы.
Но наченем с истории что классы как таковые реализовывались на С структурах. Это потом стало полнеценным классов.
Давайте пример
```
class Stack {

};
```

Как видим объявление похоже на структуру, разница ключевом слове толь `class`. Часто говорят что структура это тот же класс, только с небольшим отличием. Но нет, невсегда. Мы еще к этому вернемся.
Ну это называеться пустой класс, и размер его как структуры гарантирова будет не меньше 1 байта.
Но в таком классе смысла малло, давайте наполним его полями.
### Поля класса
Поля класса это то что и поля в структуре, т.е. они могут быть как встроеного типа, так и быть пользовательским. Но в классе в рамках ООП поля описывают состояние объекта этого класса. Т.е. синаксически это одно и тоже, но с другой семантикой. Ок, вернемся к нашему стеку. Что такое стек? это структура данных работающая по принципу LIFO, т.е. последний зашел и первым вышел. Стек это впринципе ограниченая каким то размером структура данных. Т.е. нам надо определить константу соответсвующая размеру стека, и важное это как мы будем представлять стек в памяти. Стек впринципе реализует идею массива, только с невозможностью получения доступа к элементу по индексу. Ок, т.е. у нас внутренне состоянии стека будет массива ограниченого костантой размера. Давайте добавим это.
```cpp
class Stack {
  int array[255];
};
```
ОК, у нас есть стек как пользовательский тип, который представляет из себя массив. Вопрос чем это отличаеться от структуры? В такой форме почти многим. Во первых если таким способом, если это вопрос структуры, то мы объявляем как С структуру со всеми вытекающими последствиями для С, без какой либо ООП магии. Таким объявлением, вместо `class` написать `struct`, мы гарантируем соместимость с С структурами. Мы будем к сравнениям возращатьс очень часто.
Но есть важное еще отличие это уровни доступа, т.е. если мы создадим объект этого типа и попытаемся получить доступ к полю, как мы делали это со структурой то получим ошибку компиляции.
```cpp
  Stack st;
  std::cout << st.array[0] << std::endl;
```
Мы получим интересную ошибку, типа мы пытаемся использовать что то `private`. Так что это такое то. Это называються уровни доступа. Их есть 3-и
1. **private** если объявлять что то в этом разделе то мы не сможем получить доступ к этим мемберам, объявленых в этом разделе .
2. **public** все что сдесь объявлено, являеться внешне доступным, т.е. все имеют доступ к мемберам объявленым в этом разделе.
3. **protected** это относить к наследованию, и мы его более подробно рассмотрим когда будет рассматривать наследования.

Класс по умолчанию неявно объявляет все пренадлежаще разделу `private`. Т.е. описанный выше класс стек неявно определен следующим образом.
```cpp
class Stack {
 private:
  int array[255];
};
```

Теперь становиться ясно почему мы не  можем вызвать поле этого класса напрямую, т.к. он закрытый. А почему мы можем так использовать структуру, потомочту она неявно объявлена как.
```cpp
class Stack {
 public:
  int array[255];
};
```

Ок, но мы упустили момент что мы объвили объект этого класса, это есть уже физическое представление нашего класса в памяти. Стоит заметить, что каждый объект типа стек имеет свое независимое сотояние от других объектов.
Ну про объекты много говорить нечего, это привычные переменные которые мы с Вами сто раз уже объявляли.

### Методы класса
Ок, что мы имеем у нас есть объявление класса стека, которое состоит с одного только фиксированого размера доступ к которому мы не может получить, хотя копировать, т.е. присваивать между собой объекты класса стек мы можем. Ну это не решает проблемы. Но исходя икапсуляции мы молодцы, а вот теперь мы должны прийти к идеи абстракции. Т.е. мы должны предоставить публичный интерфейс для работы  с таким стеком.
Ок, начнем. Но прежде чем перейти к реализации мы должны определиться что наш класс стека должен предоставлять в качестве публичного интерфейса для работы со стеком.

1. Это добавление элемента в стек.
2. Это удаление элемента со стека.
3. Получения элемента с вершины стека.

Ок, так как эти методы писать? Методы это тежи функции, т.е. с той же логикой работы, только они принадлежат области класса в котором они определены. Что такое область в котором определены? Главное их свойство это возможность работы внутри этих метов с полями нашего класса, т.е. читать, модифицировать и т.д. Но есть и еще одно важное отличие. Для понимание этого мы вспомним как мы обращаемся к полям класса или структуры, неважно, мы через символ `.` это для обычного объекта или символа `->` для доступа через указатель получаем доступ к полю. Так вот чтобы вызвать метод принадлежащий этому классу, его надо вызывать так же как и получение доступа к полю, т.е. через теже специальными символы. Поэтому и говорят что метод принадлежит классу(есть правда немного отличия для статических методов). Но мы еще вернемся к методу детального рассмотрения.
Ок, давайте заимплементим эти методы внутри класса.
Сначало добавим метод добавления элемента в стек. Для этого немного покумекаем  в каких случаях у нас ошибочная вставка в каких мы успешно добавляем. Нам надо добавить еще одну переменную которая будет текущим положением указателя на вершину стека. Указатель это громко, но так как мы поднизом используем массив, то и быдем применять понятие целочисленого индекса. И тогда если мы добавляем элемент в стек и при этом наш указатель равен максимальному размеру стека, тогда мы не должны добавлять элемнт в стек, иначе мы добавляем элемент в стек и увеличиваем индекс вершины стека. *Ну еще одно уточнение* нам надо придумать что мы будем возращать пользователю нашего класса. Для этого я решил что мы будем возращать пару статус операции и сообщение. Для этого мы напишем свою структуру представляющей из себя пару. Можно было бы использовать готовую такую структу реализованную в стандартной библиотеке, но зачем нам тянуть весь заголовочный файл, если у нас примитив для одного только типа.
```cpp

struct Pair {
  bool status;
  const char* msg;
};

struct Value {
  bool status;
  int value;
};

class Stack {
 public:
  Pair push(int value) {
    Pair res {false, ""};
    if (current_position == 255) {
      res.msg = "Satck is full";
      return res;
    }
    array[++current_position] = value;
    res.status = true;
    res.msg = "Success add to stack";
    return res;
  }

 private:
  constexpr static unsigned SIZE_STACK = 255;
  int array[SIZE_STACK];
  int current_position;
};

```

Я думаю что объяснять зачем мы нашу функцию написали в разделе `public` не нужно. Но мы видим что мы перед нашими полями данных добавили явно секцию `private`, это сделано в связи с тем что секция ее область действия(шикарное словосочетание), распостраняеться до ближайшей другой секции. Исходя из моих слов каламбуров, то если мы явно не укажем `private` то наши данные будет публичные, т.к. мы выше объявили раздел `public`. Тут можно было и подругом пойти, т.е. вначале писать поля данные, а потом открытый интерфейс, в этом случае мне не пришлось бы писать секцию `private`. Но я придерживаюсь стиля написания, что вначале идут публичные данные, потом протектед, а потом приватные.
Вообщем с примера видно что в случае если мы не можем что то добавить на стек, мы возращаем ошибку, и наче мы возращаем статус ОК, и увеличиваем индекс стека.
Давайте более детально посмотрим под капотом что же такое метод и в чем его сахар. Вся суть, если вспомнить, это то что методы принадлежат области класса(и это важно, они есть частью его scope). Т.е. таким образом, это некий сахар для компилятора он должен же понимать с какими вы полями можете работать а с какими нет, т.е если вы пытаетесь обатиться не принадлежащий этому классу полям. Т.е. таким образом компиялтор выполняет много проверок. Но есть вопросик, т.е. если он принадлежит этому классу, то значит наверное размер объекта должен же быть больше. Вобщем вопросов у меня как в новичка было много. Но начнем с того что метод это таже функция, **она ОДНА**, метод не создаеться для каждого объекта, у нее только один адресс, она одна в памяти кода и все!!! Метод есть частью(сахар) класса. ОК, кэп сказал я, так а откуда он тогда понимает какие именно, верней сказать какие поля какого объекта он меняет???? АААА??? Тут С++ превзошел себя, методы в С++ вызываються по соглашению thiscall(вспоминаем с прошлых лекций что такое соглашение о вызовах). Капец как все сложно, нет Вася, все просто) Это означает что компилятор добавляет неявно еще один дополнительный параметер это указатель на объект который вызвал этот метод. И тогда в методе появляеться такой скрытый объект как **`this`**. Т.е. напишем наше тело функции, так как его применяет компиялтор
```cpp
Pair push(int value) {
  Pair res {false, ""};
  if (this->current_position == 255) {
    res.msg = "Satck is full";
    return res;
  }
  this->array[++(this->current_position)] = value;
  res.status = true;
  res.msg = "Success add to stack";
  return res;
}
```
Что это за .... Ок, сразу беру sizeof пустого класса в которм только объявлено одно поле `int` и метод который что то делает с этим полем, берем его размер класса, и только 8байт, это что за чепуха, где размер моего `this`, где его вообще компилятор его обьявляет. Ответ шикарен, нигде, его в классе нет!. Попорядку. Я говорил что соглашение о вызове есть такое `thiscall`, прикол в том что при вызыве метода, пример такой
```
  Stack st;
  st.push(90);

```
Компилятор сделает вот такую гадость
```
 Stack st;
 push(&st, 90);
``` 
Т.е. он передает туда неяввно указатель на объект который вызывает этот метод, тогда становиться понятно какому объекту мы меняем данные. Если попытаться так вот вызвать метод, как возможную генирацию, то мы получим ошибку(наверное что нет такой функции). Так мы только вызовем получив указатель на этот метод. И тут мы опа приходим еще к одной части, это то что указатель на функцию отличаеться от указателя на метод, и понятно это доплнительным параметром.
Ну если в метод передаеться указатель `this`, как скрытый указатель, то стало быть можно вызывать метод с null указателем, если в методе нет работы с данными классами. Давайте попробуем это будет как тест.
```cpp
#include <iostream>

class Debug {
 public:
  ....
  void test() {
    std::cout << "test" << std::endl;
  }
 private:
  ...
};

// и вызов
int main(int argc, char const *argv[]) {
  ...
  Debug* ptr;
  ptr->test();
  return 0;
}

```

Это некое доказательство того что я вам распинаясь пытался рассказать. Т.е. как видим, мы по null указателю вызвали метод, с этого следует то что метод это просто сахар реализуем компилятором, не более того. Но **важно** если вы в этот метод добавите поле то программа у вас упадет, так под поля класса память то небыла выделена.
Ок, начитавшись теории давайте добавим еще один метод это удаление элемента с верщини стека. Всю реализацию методов мы пишим внутри `class Stack`
**stack.cpp**
```cpp
Pair pop() {
  Pair res {false, "Stack empty"};
  if (current_position == -1) {
    return res;
  }
  --current_position;
  res = {true, "Success"};
  return res;
}
```
Ок, я думаю ту еще все проще, проверяем если стек пустой, то возращаем ошибку, иначе уменьшаем интекс стека на дно).
И получение элемента с вершины стека. 
```cpp
Value top() {
  Value res {false, 0};
  if (current_position == -1) {
    return res;
  }
  res = {true, array[current_position]};
  return res;
}
```

Просто все до немогу) проверяем что не пуст ли стек, если да то ретурн ошибочку, иначе возращаем значение на вершине стека. Мы добавили новый тип, возращаемое значение с вершины стека, содержащее статус, и значение.

Если посмотреть немного внимательный на этот метод, и вспомнить что ООП представляет состояние объекта, т.е. вызвав метод мы не знаем что там на самом деле происходит если это скрыто реализацией, например библиотеки. И хотелось бы глядя на интерфейс этого класса быть увереным что если он описан как не меняющий состояние объекта, то он не должен его менять. Правильно сказать чтобы не было побочных эфектов. Возращаясь к нашему методу, мы можем увидеть, что он просто берет на вершине стека значение и возращает его. Т.е. этот метод не меняет состояние объекта, а как нам гарантировать что вызвав этот метод, объект не изменит свое состояние, не просто написав описание, а гарантировать на уровне языка. Для  этого случая применяют так называемые const методы. Смысл их в том что внутри этих методов мы можем читать только поля класса, но не менять их. Запутано согласен. Дальше еще хуже). Идея const методов в том что они явно гарантируют целостность объекта, и не изменяемость состояния объекта. Но еще что хуже внутри этих методов можно вызывать только такие const методы, но это логично. Короче давайте перепишем наш метод `top` сделав его константным.
```cpp
class Stack {
 public:
 ....
  Value top() const {
    Value res {false, 0};
    if (current_position == -1) {
      return res;
    }
    res = {true, array[current_position]};
    return res;
  }
 private:
 ...
};

```
Как видим наше объявление и определение метода немного изменилось, мы добавили `const` в конец метода, который есть теперь частью интерфейса. То теперь читающий наш код, увидит определение нашего класса, посмотрит публичный интерфейс нашего класса, и посмотрев на метод `top` он будет уверен что вызвав этот метод никаких побочных эфектов не будет.
Ок, но это не все на счет const метода, они еще играют роль когда объявляються объекты класса стек. Суть в том что объявив объект как константный мы можем вызывать только константные методы, тогда как не константные объекты могут вызывать как константные методы так и обычные. А почему должно появиться в голове у каждого вопрос, т.е. как компилятор будет гарантировать не изменяемость объекта, ведь как мы выше рассмотрели функция она одна и вызываеться для всех объектов. А сахар то в том, какой туда приходит `this`, **он там есть как указатель на const**. Все так просто.

Как бы все наш класса стека готов давайте будем тестить
```cpp
#include <iostream>

class Stack {
  ...// реализация нашего класса стек(push pop top)
};

int main(int argc, char const *argv[]) {
  Stack st;
  st.push(90);
  st.push(100);
  std::cout << st.top().value << std::endl;

  st.push(1);
  std::cout << st.top().value << std::endl;
  st.pop();
  st.pop();
  std::cout << st.top().value << std::endl;
  st.pop();
  auto value = st.top();
  if (value.status) {
    std::cout << value.value << std::endl;
  } else {
    std::cout << "Stack is empty" << std::endl;
  }
  auto res = st.pop();
  std::cout << res.msg << std::endl;
  res = st.pop();
  std::cout << res.msg << std::endl; 
  return 0;
}
```

И если мы выполним этот код, то увидем не то что мы ожидаем.
```
100
1
90
0
Success
Stack empty
```

Т.е. видим что у нас траблы с индексом, что то в коде мы не так сделали. Т.е. мы добавили три элемента в стек, получили то что ожидаем, потом вытолкнули, получили какойто 0, а должны получить ошибку.
Ок, я думаю что в этом коде полноценно не хватает еще одного метода.
Т.е. нам надо реализовать метод который вернет нам текущее положение индекса. Ок, все просто, но мы уже с Вами прокачены немного в понятии метода, и мы делаем анализ и понимаем, что этот метод хороший кандидат на константность, т.к. он не меняет состояние объекта, он просто возращает значение индекса стека. Ок, с этим разобрались.
```cpp
class Stack {
 public:
  ...
  int GetCurrentPosition() const {
    return current_position;
  }
  ...
};
```

Вообщем все просто. И на этом можно было бы закрывать первый наш эта написания класса Stack. Но мы то продвинутые программисты, и хочем писать качественный код. Давайте внесем некотоую косметику в наш код. А именно меня раздражает тот факт неявного преобразования типов в С++, ведь у нас то стек целого типа `int`. И хотелось бы присваивать туда значения которые могут поместиться в этот тип. А запретить например `long int`, `float`, `doouble`, `long double`. Вернувшись к разделу о функциях и пергрузках мы вспоминаем как это надо делать. Т.е. есть два способа, это сделать объявление и не писать определение, но как по мне полная ... Но начиная с С++11 есть новая тема а имеено понятие удаляемости функций(= delete). О годиться, давайте напишем объявление этих функций как удаляемые.
```cpp
class Stack {
 public:
  Pair push(int value);

  Pair push(unsigned int) = delete;
  Pair push(long) = delete;
  Pair push(long long) = delete;
  Pair push(float) = delete;
  Pair push(double) = delete;
  Pair push(long double) = delete;
  ...
};
```
Как видим все просто пишем просто объявление и добавляем ключевое слово `delete`. И теперь попытаемся, добавить элемент например вещественный в стек, то получим ошибку компиляции.
```cpp
...
st.push(100.20);
``` 
error: use of deleted function ‘Pair Stack::push(double)’
```

Круто, мы не только реализовали функцилнальный стек, но и еще безопасный.

```

### Деструкторы и контсрукторы.
Теперь вернемся к нашему багу. Как бы все ок, класс работает объекты создаються, можно даже их друг другу присвваивать. Иногда даже непонятно как это происходит, ведь у нас есть массив, а мы как знаем с курса о массивах, то массивы нельзя друг другу присваивать. Но то как говориться потом. Давайте с бага начнем. Если копнуть наш класс, то мы увидим, что условием проверки пуст ли стек есть `if (current_position == -1)`. Ок, я думаю во многих возник этот вопрос когда мы проэктировали наш класс, а вопрос такой чему же равно начальное занчение этой переменной. Если взять аналогию со структурой, то мы вспомним что если явно не проинициализировать структуру, то получим муссор. Ок, так как нам вывести то поле текущего индекса, ведь оно приватное, а для этого у нас есть метод `Stack::GetCurrentPosition()`. Ну давайте его вызовем в начале после создания объекта.
```
  Stack st;
  std::cout << st.GetCurrentPosition() << std::endl;
```

На экране мы получим 0. Но также как и для структур это есть неинициализированное поле. Для классов  в С++ генерируется конструкторы и деструкторы.
В двух словах что это такое. Это тежи функции, но не теже, у них есть четкое правило они имеет такое же имя функции как и имя класса, и не иммеют возращаемого значения. А зачем это, и как если это функция то нет возращаемого значения. Да все просто, его идология быть близкой к тематике встроенных типов, вот и все. Т.е. получаеться что какимто образом компиятор неявно создает функцию конструктор, которая и инициализирует наши переменные. Но чтобы перейти дальше, **важный момент** то что компилятор не просто гененрирует методы эти по умолчанию, а еще выполняет некую скрытую магию за нас(это будет более понятно при рассмотрении наследования, и виртуальных функций), например выделяет память под наши поля класса, может инициализировать их началным значение, и делает выравнивание этих полей. Но нас сейчас как раз именно интересует инициализация полей. Как было сказано выше это происходит благодаря тому что компилятор неявно добавляет нечто в наш класс.
``` cpp
class Stack {
 public:
  Pair push(int value) {
    ...
  }
  ....
  Stack() = default;
  Stack(const Stack& st) = default;
  Stack& operator= (const Stack& rhs) = default;
  ~Stack() = default;
 private:
   ...
};

```
Т.е. компилятор неявно генерирует, два конструктора(если быть честным то 3и, но так как мы не рассматриваем оперетор перемещение, то опустим его описание).
1. Это конструктор по умолчанию, смысл его в том чтобы указать дефолтную иницализацию для полей. Т.е. например, `int` присвоить ноль, указатель инициализировать nullptr и т.д. Вот как раз он и вызываеться для инициализации наших полей. Т.е. в нешем случае это
```cpp
  Stack st;
``` 
2. Конструктор копирования, суть его проста до немогу, а имено **инициализировать** новый объект значениями уже существуещего объекта. Ну еще чтобы более было ясно, это то что бы вести себя как встроинные типы.
```cpp
 Stack st;
 Stack cp_st {st};
 // это аналогично
 /*
 int a = int();

 int b(a);
 */
```

А почему не возращает значение, так а зачем если он и так конструирует наш объект. Но ок, веренемся к нашему примеру, так а как нам инициализировать наш индекс значением. Ну ок давайте попробуем инициализировать его в теле этого конструктора как привычная нам работа.
```cpp
class Stack {
public:
 Stack() {
   current_position = -1;
 }
 ...
};
```

И запущаем, и вуаляяяя, мы получили тот результат который мы ожидали от стека.
```
-1
-1
100
1
90
Stack is empty
Stack empty
Stack empty
```

Как видим с результата вывода на консоль, то начальные значения индекса теперь -1, и последний элемент у нас 90, а при попытке вытолкнуть элемент со стека то мы получим сообщение что стек пуст.
Тут **надо подметить** что мы убрали `default` при объявлении конструктора, тем самым сказали что мы сами решим как мы хотим. 
Как бы все ок, но есть подводный камень об который сталкиваються новички. Это так называемый список инициализации.
Все дело втом в каком порядке у нас все это дело вызываеться. Я же говорил что магия происходит компиялятором. А все дело в том что до вызова конструктора сначало выделяеться память под поля класса, **и важно в том порядке в котором они объявлены**, и инициализируються дефолтным значением. Т.е. в нашем классе, как мы написали инициализацию поля, то получаеться мы ей устанавливаем значение два раза. ААААА дичь! А как ей инициализировать один только раз, но тем чем мы хочем. То для этого и используються списки инициализауции. Давайте нарисуем их сразу
```
class Stack {
public:
  Stack()
   : current_position (-1) {
  }
};
```
Конструкция проста до ужаса, мы просто добавили после конструктора двоеточие и указали начальное значение для нашего индекса. Этим способом мы указываем что мы инициализируем наш индекс один раз до момента выполнения тела функции. А что на счет он массива, он инициализируеться неявно, дефолтным значением, как и прежде. Т.е. компилятор все равно за нас выполняет магию) На то он и компиялтор(умная зараза).
**Важно** поля инициализируються в том порядке в котором они объявлены в классе
```cpp
class Stack {
 public:
 ...
 private:
  int array[255];
  int current_position;
};
```

Т.е. в нашем случае будет проинициализирован неявно массив, а потом наш индекс. А что на счет статической переменной, то помним что она не ясть частью объекта, и определяеться и инициализируеться до всех объектов класса.
Но стоит сказать то что мы сделали было актуально до С++11, а начиная уже с С++11, можно применять инициализирующее выражение  для полей класса. **Важно** инициализирующее выражение применяеться только если инициализирующее выражение есть постоянное, т.е. применяеться как в нашем случае для конструктора по умолчанию. Но если например у нас есть конструктор инициализации с несколькими параметрами, т.е. инициализация может быть разная, то лучше его неприменять. В соответсвии с Core Guidline, рекомендуенеться применять инициализирующее выражение вместо конструктора по умолчанию.
В нашем примере это
```cpp
class Stack {
 public:
 ...
 private:
  ...
  int current_position = -1;
};

``` 
Ну поздравляю это наш простой класс стек, с минимально необходимым функционалом.
Но как по мне в этот класс надо добавить возможность чтобы стек был динамическим, т.е. когда мы создавали экземпляр этого класса, мы могли указать какого он будет размера, т.е. вместо статического размера мы указали динамический.
Так что для этого нужно, а нужно нам избавиться от статического поля указывающий статический размер класса и  самого массива. А вместо этого сделать динамический массив. Т.е. удалить поля
```cpp
  int array[255];
```

И добавить указатель на `int`
```cpp
class Stack {
 ...
 private:
  int* array;
  int current_position;
  const unsigned SIZE_STACK;
};
```

И соответсвенно напишим метод который будет возращать эту константу
```cpp
class Stack {
public:
  ...
  int GetMaxStackSize() {
    return SIZE_STACK;
  }

}
```

Ок, собираем, теперь у нас ошибка, но какая. А суть ее в том что у нас не инициализированная константная переменная, и на самом деле, если вспомнить то мы знаем что константа должна быть инициализированная при создании. И тут компилятор такй хоп, а чем я ее буду инициализировать, ну есть у меня конструктор по умолчанию, а кокое значение должно быть для константы 0 или 1 или 2. И тут компилятор просто говорит короче сам решай какое должно быть значение, для этого мы должны сами установить значение константной переменной. А вопрос где ее устанавливать. В теле функции? Ответ нет, так как мы знаем что в теле мы иниицализируем уже проинициализированную переменную, т.е. это повторная инициализация. Тогда где, ответ очевиден, это список инициализации (я думаю понятно почему). И еще можно явно указать в инициализирующем выражении для поля. Я буду придпочетать вторй вариант так как он следует Core Guidline.
```cpp
class Stack {
 ...
 private:
  ...
  const int SIZE_STACK = 5;
};
```

Ок, но у нас немного уродски получаеться что мол константа устанавливаеться в поле инициализации, а индекс в дефолтном конструкторе. Вообщем давайте удалим дефолтный конструктор, и инициализируем переменные прям порядке инициализации поля. И пусть компиялтор генерирует лучший, отимизированный конструктор.
```cpp
class Stack {
 public:
  ...
 private:
  int* array = nullptr;
  int current_position = -1;
  const int SIZE_STACK = 5;
};

```

И удалим с кода все следы дефолтного конструктора. Собираем и бух, ошибка мол типа нет определения конструктора по умолчанию. Шо мы же удалили и решили компиялтор сам это генерируй. А проблема то встрочках
```cpp
  Stack(const Stack& st) = default;
  Stack& operator= (const Stack& rhs) = default;
  ~Stack() = default;
```

Указав таким способом какие мы хотим генерировать по умолчанию конструкторы, деструкторы, компилятор умывает руки от генерации дефолтного конструктора, так как он считает что вы явно указали что вы хотите что бы он генерил. Если удалить х из кода, и еще раз попытаться собрать то все у нас успешно скомпилиться.
Ок с этим разобралиьсь, так а как нам передавать меняющеся значение для константы. Давайте без лишних слов, для этого используються конструкторы со списком параметров(ненашел другого подходящего названия). Т.е. нам нужен конструктор принимающий один параметр а иммено размер нашего стрека.
```cpp
class Stack {
 public:
  Stack(int size)
  : SIZE_STACK(size) {
  }
 ...
};
```

Собрираем наш код и получаем ошибку компиляции, т.е. компилятор не может вызвать дефолтный конструктор, а предлагает альтернативные конструкторы. В данном  случае наш новый с одним парметром. А что тут происходит, а суть ее в том что если мы явно указали конструктор с параметром, то компилятор перестает генерировать дефолный конструктор, так как он не знает что туда писать, он то знает, просто он думает раз ты решил сам написать такой конструктор, то флаг тебе в руки я ничего больше делать не буду, как то так.
А хотим мы дефолтный. Ну я например нехочу. Давайте тогда если мы не хотим чтобы нащ класс имел дефолтного конструктора, давайте явно об этом скажем и не толкьо компилятору, написав при этом ключевое слово `delete`, помните о таком.
```
Stack() = delete;
```
то при попытке собрать наш код поллучим уже читающий код что мол мы пытаемся вызвать конструктор который удален.
УУУУ кул мы стали еще круче. Так а что теперь с указателем, нам надо где - то выделить память. А где это надо делать? Тут два варианта, один из которых я не фанат, а предпочитаю больше другой. Начнем с первого. Все мы понимаем что если мы создаем наш динамический массив, то его можно создавать написав например функцию `Allocate`, но не мне не очень к тому же источник ошибок, а если мы ее забудем вызвать, а вызвем например функцию получения элемента  с вершины стека. То можем получить, а не не получим ведь мы правильные программисты, и пишем тесты на наши функции). Но да ладно, мы это сделаем в конструкторе, т.е. при создании объекта мы динамически выделим память под стек, и нам не надо париться когда нам надо вызвать фкункцию алокации памяти, за нас это сделает могущий компилятор. Нус приступим.
```cpp
Stack(int size)
: SIZE_STACK(size) {
  if (SIZE_STACK > 0) {
    array = new int [SIZE_STACK]{};
  }
}
```

Как  видим с примера все просто мы проверяем больше ли единицы наш размер запрашиваемого выделения стека. И если все ок, то выделяем память под стек. Но тут моментик есть, мы не можем как в других функциях возращать стату, ведь конструктор то ничего и не возращает. Ну ок, супер теперь тестируем.
```cpp
#include <iostream>
class Stack {
  ...
};

int main(int argc, char const *argv[]) {
  Stack st{10};
  std::cout << st.GetMaxStackSize() << std::endl; 
  std::cout << st.GetCurrentPosition() << std::endl; 
  Stack st_more{20};
  std::cout << st_more.GetMaxStackSize() << std::endl; 

  st.push(10);
  std::cout << st.top().value << std::endl; 
  st.pop();
  std::cout << st_more.GetCurrentPosition() << std::endl; 

  std::cout << st.pop().msg << std::endl;

  return 0;
}
```
Ок, запускаем проверяем работает, размер стека для разных объетов разный. Круто. Но добавления динамики добавляет еще массу проблем. Первая из них это то что надо удалить выделеный массив, т.е. за собой почистить. И для этого как раз и пригодиться нам деструктор.
Деструктор это противоположность конструктора, т.е. он вызваеться когда о у нас удаляеться объект, правильно будет сказать разрушаеться. Т.е. выходит с области видимости, это для автоматической области, или мы явно удаляем его выделеного на куче.
Ну в отличие от разнообразия конструкторов то дееструктор может быть только один. **Важно** деструкторы не принимают параметров.
Ок теперь понятно, давайте добавим в деструктор удаление массива.
```cpp
class Stack {
public:
  ~Stack() {
    if (array != nullptr) {
      delete [] array;
    }
  }
...
};
``` 
Деструктор иммет такое же имя как и имя класса, но с добавлнеим символа `~`. Нуи запускаем на сборку нашу программу. Ок, отлично все работает. Таким образом в конструкторе мы выделяем память а в деструкторе ее освобождаем. Гуд) Таким образом мы с Вами реализовали идиому RAII получение ресурса есть и иницализация Resource Acquisition Is Initialization (RAII). Идея его заключаеться в том чтобы не забыть очистить за собой ресурсы, то в конструкторе происходит захват этого ресурса, а в деструкторе его высбождение. Т.к. деструторы вызываються автоматически после выхода с области видимости, то мы гарантированно осбодим память(небудет memory leaks).
Класс, у нас как бы получился отличный класс, но взглянув на реализацию деструктора, и остальных функций, то мы видим что у нас может быть seg fault, так как указатель может быть null. Ок, исправим это добавим проверку указателя во всех методах.
```cpp
Pair push(int value) {
  Pair res {false, ""};
  if (nullptr == array) {
    res.msg = "Stack is not allocated";
    return res;
  }

  if (current_position == SIZE_STACK) {
    res.msg = "Satck is full";
    return res;
  }
  array[++current_position] = value;
  res.status = true;
  res.msg = "Success add to stack";
  return res;
}

Pair pop() {
  Pair res {false, "Stack empty"};
  if (nullptr == array) {
    res.msg = "Stack is not allocated";
    return res;
  }
  if (current_position == -1) {
    return res;
  }
  --current_position;
  res = {true, "Success"};
  return res;
}

Value top() const {
  Value res {false, 0};
  if (nullptr == array) {
    return res;
  }

  if (current_position == -1) {
    return res;
  }
  res = {true, array[current_position]};
  return res;
}
```

Как видно мы добавили в методы `push`, `pop`, `top` проверку не нулевой у нас ли указатель.
Супер работаем теперь с нашим классом. О а у меня есть идея давайте добавим инициализацию нашего стека на основе уже существующего стека, т.е. для этого нам надо написать конструктор который будет принимать такой же объект стека, но уже готовый, и мы его проинициализируем этим объектом, при этом передаваемый объект мы менять не будем(он должен быть константным). Для этого и применяеться конструктор копирования. Давайте его реализуем.
```cpp
Stack(const Stack& st);

Stack(const Stack& st)
: current_position(-1),
  SIZE_STACK(st.SIZE_STACK){
  array = new int[SIZE_STACK];
}
``` 
Все как бы ок, но меня смущает то факт что мы делаем практически тоже самое, как в пользовательском конструкторе. А давате сделаем вызов в конструкторе копирования пользовательский конструктор. Забегая наперед, скажу что вызов конструкторы, из другого конструктора появилась начиная с С++11, до этого писали некие `Init` методы. Ну ок, перепишем. Но гайс, стоп, а где его вызывать?? Хороший вопрос, наверное в теле конструктора копирования, это же как бы той же самый объект. Но это ошибочно. Пример
```cpp
Stack(const Stack& st) {
  Stack(st.SIZE_STACK);
}
```
Это частая ошибка новичков, в этом коде мы просто создаем временный объект и все, его время жизни до `;`. И он некак не повлияет на наш создаваемый объект. А как правильно, а правильно использовать список инициализации.
```cpp
Stack(const Stack& st)
 : Stack(st.SIZE_STACK) {
}
```

Таким способом вы говорите что создай объект используя другой конструктор, а потом выполни тело этого объекта.
Используем
```cpp
#include <iostream>

class Stack {
 ...
};

int main(int argc, char const *argv[]) {
  Stack st{10};
  std::cout << st.GetMaxStackSize() << std::endl; 
  st.push(101);
  std::cout << st.top().value << std::endl;
  Stack st_more{st};

  std::cout << st_more.GetMaxStackSize() << std::endl; 
  if (st_more.top().status) {
   std::cout << st_more.top().value << std::endl;
  } else {
    std::cout << "Stack is empty" << std::endl;
  }
  

  return 0;
}

```

Как видно из примера, то мы вызвали конструктор копирования, и видим что размеры их совпадаю, а вот содержимое стека нет. Но есть еще одно чудо, если мы закоментируем конструктор копирования, то код у нас собереться без всяких проблем. Так зачем мы это все писали, пусть сам компилятор это за нас сделает. Суть в том что даже если мы объяявили пользовательськие конструкторы(конструктор с одним параметром размер стека), то компилятор все равно генерит конструктор копирования. Но не такой как мы хотим. При генерации дефолтного конструктора копирования, происходи просто побитовое копирование полей одного класса в другой. Но если посмотреть реализацию класса, то увидим что есть маленький трабл, а именно то что мы скопируем просто указатели а не содержимое стека, и в этом случая у нас будет два указателя указывать на одну и туже область памяти. То при выходе объекта с области видимости, мы будем в деструкторах обоих объектов удалять одну и туже память. А это есть неопределенное поведение.
Ок, а если мы захтим например присвоить один объект другому, что нам для этого надо. Нам необходим метод который будет принимать один объект являющиеся левой частью опретора `=`. И внутри мы должны все скопировать содержимое одного одних полей в содержимое других другого объекта. Но мы помним что в начале компилятор генерить 2 контруктора неявно, и еще один важный это опрератор присваивания. Т.е. нам не надо писать никакой метод, компилятор все за нас это делает. Давайте попробем например присвоить объекты друг другу.
```cpp
  st_more = st;
```  
И чудо компилятор при таком присвоении выдаст нам ошибку!!!!!
```cpp
main.cpp: In function ‘int main(int, const char**)’:
main.cpp:18:13: error: use of deleted function ‘Stack& Stack::operator=(const Stack&)’
   st_more = st;
             ^~
In file included from main.cpp:2:0:
stack.hpp:4:7: note: ‘Stack& Stack::operator=(const Stack&)’ is implicitly deleted because the default definition would be ill-formed:
 class Stack {
       ^~~~~
stack.hpp:4:7: error: non-static const member ‘const int Stack::SIZE_STACK’, can’t use default assignment operator
```

А суть этого шлака в том что мы не можем изменить контсантное поле размер массива. А почему, а все потому что этот опрератор вызываеться когда есть уже два готово свормировавшиеся объекты, а мы знаем что константы присваивать нельзя они инициализуются только один раз. Огонь. А давайте ради экперимента изменим поле размера массива на не контантное значение. И соберем нашу программу.
```cpp
class Stack {
 ...
 private:
  int SIZE_STACK = 5;
 ...
}
```

И все у нас отлично собираеться, т.е. компилятор за нас сгенерил оператор присвоение. Огонь. А такой ли он как нам надо? Запускаем программу и все ок работает. Но это неправильное поведение, если посмотреть описания оператора присвоение, то мы увидимм что он делает ровно то что делает дефолный конструктор копирования, а именно побитово копирует поля. Т.е. в нашем примере после присвоение одного стека другому мы получим что оба стека ссылаються на одну и туже область памяти. Но в нашем случае нам повезло, но в продашен коде, или в более больших программах, такого не случится у нас больше всего что программа свалиться, на попытке удалить два раза один и тот же объкт. Нам это не подходи давайте его перепишем.
```cpp
class Stack {
public:
  Stack& operator=(const Stack& st) {
  if (array != nullptr) {
    delete [] array;
  }
  current_position = st.current_position;
  SIZE_STACK = st.SIZE_STACK;
  array = new int[SIZE_STACK] {};
  for (decltype(SIZE_STACK) i = 0; i < SIZE_STACK; ++i) {
    array[i] = array[i + 1];
  }
  return *this;
  }
...
}
```

Как видно с реализации, то оператор присваивания, отличается от других неявно сгенерированых методов класса.
Начнем попорядку
1. Оператор присвоение в отличие от конструкторов возращает значение, а иммено объект находящийся справа от знака `=`. Это сделано для того чтобы присвоение объектов было подобно поведению встроенных типов (`a = b = c`). Если честно вы можете возращать что хотите, возвращение объекта это лишь соглашение.

2. В нашем примере мы должны сначало очисть прежнюю выделенную память а потом, присвоить ей уже новую. Это важно чтобы не было утечки памяти.

3. Имя оператора присваивания начинаеться с ключевого слова `operator` и дальше идет оператор который мы собираемся перегрузить. О новое слово, да таким способом мы делаем перегрузку оператора, т.е. мы говорим компилятору что если ты встретишь выражение где один объект приваивает значения другого объекта, то найди в в класса перегрузку которя это делает. Детально мы об этом потом поговорим.

4. Вы можете писать как возращаемое значение, так и входной парметр, как вам угодно. Но помните, что этим же вы меняете смысл этого оператора, который привычный для других. Есть некое соглашение, и вы его должны следовать, а не компилятор.

Супер но есть большое НООООО!!!. А то что если мы например попытаемся присвоить значение самому себе. Типа
```cpp
 st_more = st_more;
```

То  все понимают что произойдет, а тот кто не понимает. То у нас будет ситуация, когда мы удалили память, того же объекта, потом иннициализируем стек муссором. В данном примере то нет ничего критичного, но зачем нам удалять память а потом ейприсваивать муссор. Ой, а как это поправить. Смотрим что у нас есть у нас есть присваиваемый объект с левой стороны, и есть указатель this которыйй указывает на объект справа. Огонь, что уже есть. Так давайте просто сравним их адресс, тем саммым мы убедимся что они ну указывают друш на друга.
```cpp
Stack& operator=(const Stack& st) {
 if (this == &st) {
   return *this;
 }
 
 if (array != nullptr) {
   delete [] array;
 }
 current_position = st.current_position;
 SIZE_STACK = st.SIZE_STACK;
 array = new int[SIZE_STACK] {};

 for (decltype(SIZE_STACK) i = 0; i < SIZE_STACK; ++i) {
   array[i] = array[i + 1];
 }
 return *this;
}
```

Как видим мы просто в начале добавили проверку самого на себя. Круто.
А тепь уже точно можно сказать что у нас есть полноценно, хороший стек.